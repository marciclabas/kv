{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the KV docs!","text":"<p><code>KV</code> is an async key-value store interface for Python. It provides a simple API to store serializable objects.</p> <pre><code>pip install python-kv\n</code></pre> <p><code>KV</code> supports multiple backends, including the filesystem, SQLite, Redis, Azure Blob, and many more.</p> <p>Let's get started!</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The easiest way to use <code>KV</code> is via URLs:</p> <pre><code>from kv import KV\n\nkv = KV.of('sqlite://path/to/db.sqlite?table=kv', type=dict)\n</code></pre>"},{"location":"getting-started/#crud","title":"CRUD","text":"<p>A <code>KV</code> has the CRUD methods you'd expect:</p> Method Example <code>insert</code> <code>await kv.insert('user1', {'name': 'John', 'email': '...'})</code> <code>read</code> <code>await kv.read('user1') # dict</code> <code>has</code> <code>await kv.has('user1') # bool</code> <code>keys</code> <code>kv.keys() # AsyncIterable[str]</code> <code>values</code> <code>kv.values() # AsyncIterable[dict]</code> <code>items</code> <code>kv.items() # AsyncIterable[tuple[str, dict]]</code> <code>clear</code> <code>await kv.clear()</code>"},{"location":"getting-started/#cross-kv-operations","title":"Cross-KV Operations","text":"<p>You can also copy and move data between <code>KV</code>s:</p> Method Example <code>copy</code> <code>await kv.copy('user1', other_kv, to_key='other-user1')</code> <code>move</code> <code>await kv.move('user1', other_kv, to_key='other-user1')</code> <p>Let's explore the available backends!</p>"},{"location":"prefixing/","title":"Prefixing","text":"<p>Prefixing is a very simple but powerful feature of <code>KV</code>. It allows you to namespace keys and search by prefix.</p>"},{"location":"prefixing/#example","title":"Example","text":"<p>Let's say we're storing documents per user. We can prefix each's documents by their ID, so that:</p> <ul> <li>No conflicts occur between users</li> <li>We can quickly query all documents for a user</li> </ul>"},{"location":"prefixing/#namespacing","title":"Namespacing","text":"<pre><code>from kv import KV\n\nkv = KV.of('file://users', type=dict)\nkv1 = kv.prefix('user1')\nkv2 = kv.prefix('user2')\n\nawait kv1.insert('settings', {'theme': 'dark'})\nawait kv2.insert('settings', {'theme': 'light'})\n</code></pre> <p>This will yield: <pre><code>users/\n  user1/\n    settings.json\n  user2/\n    settings.json\n</code></pre></p>"},{"location":"prefixing/#prefix-querying","title":"Prefix Querying","text":"<p>Say we want to get all documents for <code>user1</code>:</p> <pre><code>user1_keys = [key async for key in kv.prefix('user1').keys()] # ['settings']\n</code></pre>"},{"location":"prefixing/#nested-prefixing","title":"Nested Prefixing","text":"<p>You can imagine a complexer scenario with nested namespacing. No problem at all!</p> <pre><code>kv.prefix('user1/images/cats')\n</code></pre>"},{"location":"prefixing/#backend-support","title":"Backend Support","text":"<p>Prefixing has a default implementation using string prefixes. Specific backends may provide more efficient implementations (like the filesystem).</p> <p>To check out the details, check out the specific backend pages. Links can be found in the Supported Backends page.</p>"},{"location":"supported-backends/","title":"Supported Backends","text":"<p>Multiple backends are supported by default. And you can always roll out your own!</p>"},{"location":"supported-backends/#installation","title":"Installation","text":"<p>To install specific backends, install the corresponding extras. For example:</p> <pre><code>pip install python-kv[fs,redis]\n</code></pre>"},{"location":"supported-backends/#schemas","title":"Schemas","text":"<p>To access a specific backend, simplest is to use URLs. For example:</p> <pre><code>from kv import KV\nkv = KV.of('file://path/to/folder')\n</code></pre>"},{"location":"supported-backends/#supported-backends_1","title":"Supported Backends","text":"Backend Example URL Installation Filesystem <code>file://path/to/folder</code> <code>python-kv[fs]</code> SQLite <code>sqlite://path/to.db?table=kv</code> No deps SQL (<code>sqlalchemy</code>) <code>sql+postgresql://user:pass@host/db</code> <code>python-kv[sql]</code> Redis <code>redis://localhost:6379/0</code> <code>python-kv[redis]</code> Azure Blob Storage <code>azure+blob://&lt;connection_string&gt;</code> <code>python-kv[blob]</code> Azure Cosmos DB <code>azure+cosmos://&lt;connection_string&gt;</code> <code>python-kv[cosmos]</code> HTTP Client <code>http://example.com/kv</code> <code>python-kv[client]</code> <p>Next up, a powerful mechanism: prefixing</p>"},{"location":"backends/blob/","title":"Azure Blob KV","text":"<p>The <code>BlobKV</code> stores items as blobs in an Azure Blob Storage service. You can also use <code>BlobContainerKV</code> to store items in a specific container.</p>"},{"location":"backends/blob/#example","title":"Example","text":"<pre><code>from kv import KV, BlobKV, BlobContainerKV\nblob = KV.of('azure+blob://&lt;connection string&gt;', type=dict)\n# BlobKV\n\ncontainer = KV.of('azure+blob://&lt;connection string&gt;?container=user1')\n# BlobContainerKV\n\nawait blob.insert('key1', {'value': 1})\nawait container.insert('nested/key2', {'value': 2})\nawait container.insert('key3', {'value': 3})\n</code></pre> <p>This will yield: <pre><code>default-container/\n  key1\n\nuser1/\n  nested/\n    key2\n  key3\n</code></pre></p>"},{"location":"backends/blob/#datatypes","title":"Datatypes","text":"<ul> <li><code>str|bytes</code>: written as-is</li> <li><code>dict|list|dataclass|etc</code>: validated as JSON using <code>pydantic</code></li> </ul>"},{"location":"backends/blob/#prefixing","title":"Prefixing","text":"<p>Prefixing a <code>BlobKV</code> a single level yields a <code>BlobContainerKV</code>. Further nesting falls back to prefixing blob names.</p> <pre><code>blob = KV.of('azure+blob://&lt;connection string&gt;') # -&gt; BlobKV\n\ncontainer = blob.prefix('user1') # -&gt; BlobContainerKV\n# equivalent to:\ncontainer = KV.of('azure+blob://&lt;connection string&gt;?container=user1')\n</code></pre>"},{"location":"backends/cosmos/","title":"Azure Cosmos KV","text":"<p>The <code>CosmosKV</code> stores items as blobs in an Azure Cosmos DB. You can also use: - <code>CosmosContainerKV</code> to store items in a specific container - <code>CosmosPartitionKV</code> to store items in a specific partition (within a container)</p>"},{"location":"backends/cosmos/#example","title":"Example","text":"<pre><code>from kv import KV, CosmosKV, CosmosContainerKV, CosmosPartitionKV\n\ncosmos = KV.of('azure+cosmos://&lt;connection string&gt;', type=dict)\n# CosmosKV\n\ncontainer = KV.of('azure+cosmos://&lt;connection string&gt;?container=user1')\n# CosmosContainerKV\n\npartition = KV.of('azure+cosmos://&lt;connection string&gt;?container=user1&amp;partition=partition1')\n# CosmosPartitionKV\n\nawait cosmos.insert('key1', {'value': 1})\nawait container.insert('key2', {'value': 2})\nawait partition.insert('key3', {'value': 3})\n</code></pre> <p>This will yield: <pre><code>default/\n  default/\n    key1\n\nuser1/\n  default/\n    key2\n  partition1/\n    key3\n</code></pre></p>"},{"location":"backends/cosmos/#datatypes","title":"Datatypes","text":"<p>All types are serialized as JSON using <code>pydantic</code>. <code>CosmosKV</code> doesn't support binary data.</p>"},{"location":"backends/cosmos/#prefixing","title":"Prefixing","text":"<p>Prefixing a <code>CosmosKV</code> a single level yields a <code>CosmosContainerKV</code>. Prefixing two levels yields a <code>CosmosPartitionKV</code>. Further nesting falls back to prefixing blob names.</p> <p>These single-level examples are equivalent:</p> <pre><code>KV.of('azure+cosmos://&lt;connection string&gt;').prefix('container')\nKV.of('azure+cosmos://&lt;connection string&gt;?container=container')\n</code></pre> <p>And so are these double-level examples: <pre><code>KV.of('azure+cosmos://&lt;connection string&gt;').prefix('container').prefix('partition')\nKV.of('azure+cosmos://&lt;connection string&gt;').prefix('container/partition')\nKV.of('azure+cosmos://&lt;connection string&gt;?container=container').prefix('partition')\nKV.of('azure+cosmos://&lt;connection string&gt;?container=container&amp;partition=partition')\n</code></pre></p>"},{"location":"backends/filesystem/","title":"Filesystem KV","text":"<p>The <code>FilesystemKV</code> stores items as files in a (nested) directory.</p>"},{"location":"backends/filesystem/#example","title":"Example","text":"<pre><code>from kv import KV, FilesystemKV\nkv = KV.of('file://path/to/folder', type=dict) # -&gt; FilesystemKV\n\nawait kv.insert('key1', {'value': 1})\nawait kv.insert('nested/key2', {'value': 2})\nawait kv.insert('key3', {'value': 3})\n</code></pre> <p>This will yield: <pre><code>path/to/folder/\n  key1.json\n  nested/\n    key2.json\n  key3.json\n</code></pre></p>"},{"location":"backends/filesystem/#file-extensions","title":"File Extensions","text":"<p>By default, the extension is determined by the data type:</p> <pre><code>KV.of('file://path/to/folder', type=dict) # -&gt; .json\nKV.of('file://path/to/folder', type=str) # -&gt; .txt\nKV.of('file://path/to/folder', type=bytes) # -&gt; (no extension)\n</code></pre> <p>Or you can specify it manually:</p> <pre><code>KV.of('file://path/to/folder?extension=.jpg') # -&gt; .jpg\n</code></pre>"},{"location":"backends/filesystem/#datatypes","title":"Datatypes","text":"<ul> <li><code>str|bytes</code>: written as-is</li> <li><code>dict|list|dataclass|etc</code>: validated as JSON using <code>pydantic</code></li> </ul>"},{"location":"backends/filesystem/#prefixing","title":"Prefixing","text":"<p>The filesystem backend supports prefixing by creating nested directories.</p> <p>All of these are equivalent:</p> <pre><code>KV.of('file://users').prefix('user1').prefix('nested')\nKV.of('file://users').prefix('user1/nested')\nKV.of('file://users/user1').prefix('nested')\nKV.of('file://users/user1/nested')\n</code></pre>"},{"location":"backends/http/","title":"HTTP Client/Server KV","text":"<p>You can serve any <code>KV</code> using <code>ServerKV</code>, and access it using <code>ClientKV</code>.</p>"},{"location":"backends/http/#example","title":"Example","text":""},{"location":"backends/http/#server","title":"Server","text":"<pre><code>import uvicorn\nfrom kv import KV, ServerKV\n\nkv = KV.of('file://path/to/folder')\napi = ServerKV(kv) # FastAPI\n\nuvicorn.run(api, host='0.0.0.0', port=8000)\n</code></pre>"},{"location":"backends/http/#client","title":"Client","text":"<pre><code>from kv import KV\n\nkv = KV.of('http://localhost:8000')\n</code></pre>"},{"location":"backends/http/#authentication","title":"Authentication","text":""},{"location":"backends/http/#built-in-token-mechanism","title":"Built-in Token Mechanism","text":"<p>Simplest is to use this built-in mechanism for token-based authentication:</p>"},{"location":"backends/http/#server_1","title":"Server","text":"<pre><code>import uvicorn\nfrom kv import KV, ServerKV\n\nkv = KV.of('file://path/to/folder')\napi = ServerKV(kv, token='supersecret') # FastAPI\n\nuvicorn.run(api, host='0.0.0.0', port=8000)\n</code></pre>"},{"location":"backends/http/#client_1","title":"Client","text":"<pre><code>from kv import KV\n\nkv = KV.of('http://localhost:8000?token=supersecret')\n</code></pre>"},{"location":"backends/http/#custom-authentication","title":"Custom Authentication","text":"<p>There's no authentication by default. You can easily use any mechanism you want.</p>"},{"location":"backends/http/#server_2","title":"Server","text":"<p>Use <code>fastapi</code>'s middleware:</p> <pre><code>import uvicorn\nfrom kv import KV, ServerKV\n\nkv = KV.of('file://path/to/folder')\napi = ServerKV(kv, token='supersecret') # FastAPI\n\n@api.middleware('http')\nasync def auth(request, call_next):\n  token = request.query_params.get('token')\n  if token != 'supersecret':\n    return JSONResponse(status_code=401, content={'error': 'Unauthorized'})\n  return await call_next(request)\n\n\nuvicorn.run(api, host='0.0.0.0', port=8000)\n</code></pre>"},{"location":"backends/http/#client_2","title":"Client","text":"<p>Pass a custom request function:</p> <pre><code>from typing import Literal, Mapping\nfrom kv.http import ClientKV, Request\n\nasync def my_request(\n  self, method: Literal['GET', 'POST', 'DELETE'], url: str, /, *,\n  data: bytes | str | None = None, params: Mapping[str, str] = {}\n) -&gt; Request:\n  ...\n\nkv = ClientKV('http://localhost:8000', request=my_request)\n</code></pre>"},{"location":"backends/sql/","title":"SQL KV","text":"<p>The <code>SQLKV</code> stores items in a SQLite table with columns <code>(key, value)</code>. It uses <code>sqlalchemy</code> to connect to the database.</p>"},{"location":"backends/sql/#example","title":"Example","text":"<pre><code>from kv import KV, SQLKV\nkv = KV.of('sql+postgresql://user:passowrd@mydatabase.com/db?table=kv') # -&gt; SQLKV\nkv = KV.of('sql+sqlite:///path/to.db?table=kv') # -&gt; SQLKV\n# any backend supported by sqlalchemy\nkv = KV.of('sql+&lt;sqlalchemy connection string&gt;?table=kv') # -&gt; SQLKV\n\nawait kv.insert('key1', {'value': 1})\nawait kv.insert('key2', {'value': 2})\n</code></pre> <p>This will yield:</p> <p>Table <code>kv</code></p> KEY (TEXT) VALUE (JSON) <code>key1</code> <code>{'value': 1}</code> <code>key2</code> <code>{'value': 2}</code>"},{"location":"backends/sql/#datatypes","title":"Datatypes","text":"<ul> <li><code>bytes</code>: <code>BLOB</code> SQLAlchemy type</li> <li><code>str</code>: <code>String</code> SQLAlchemy type</li> <li><code>dict|list|dataclass|etc</code>: <code>JSON</code> SQLAlchemy type, validated using <code>pydantic</code></li> </ul>"},{"location":"backends/sqlite/","title":"SQLite KV","text":"<p>The <code>SQLiteKV</code> stores items in a SQLite table with columns <code>(key, value)</code></p>"},{"location":"backends/sqlite/#example","title":"Example","text":"<pre><code>from kv import KV, SQLiteKV\nkv = KV.of('sqlite://path/to.db?table=kv', type=dict) # -&gt; SQLiteKV\n\nawait kv.insert('key1', {'value': 1})\nawait kv.insert('key2', {'value': 2})\n</code></pre> <p>This will yield:</p> <p>Table <code>kv</code></p> KEY (TEXT) VALUE (JSON) <code>key1</code> <code>{'value': 1}</code> <code>key2</code> <code>{'value': 2}</code>"},{"location":"backends/sqlite/#datatypes","title":"Datatypes","text":"<ul> <li><code>bytes</code>: <code>BLOB</code> SQLite type</li> <li><code>str</code>: <code>TEXT</code> SQLite type</li> <li><code>dict|list|dataclass|etc</code>: <code>JSON</code> SQLite type, validated using <code>pydantic</code></li> </ul>"},{"location":"blog/","title":"Blog","text":""}]}